{"version":3,"sources":["../src/index.ts","../src/graph/edge.ts","../src/graph/index.ts","../src/graph/node.ts","../src/graph/serializer.ts","../src/infinite-canvas.ts"],"sourcesContent":["import { Graph } from \"./graph\";\nimport { INode, Node } from \"./graph/node\";\nimport { Edge } from \"./graph/edge\";\nimport { Serializer } from \"./graph/serializer\";\nimport { InfiniteCanvas } from \"./infinite-canvas\";\n\nexport { Graph, INode, Node, Edge, Serializer, InfiniteCanvas };\n","import { INode } from \"./node\";\n\n/**\n * Edge class represents an edge in a graph.\n * @class\n * @property {Node} from - The node the edge is coming from.\n * @property {Node} to - The node the edge is going to.\n * @property {string} color - The color of the edge.\n * @property {number} width - The width of the edge.\n */\nexport class Edge {\n  to: INode;\n  from: INode;\n  color: string = \"#fff\";\n  width: number = 2;\n\n  constructor(from: INode, to: INode) {\n    this.from = from;\n    this.to = to;\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    // ctx.beginPath();\n\n    const startX = this.from.x + this.from.width;\n    const startY = this.from.y + this.from.height / 2;\n\n    const endX = this.to.x;\n    const endY = this.to.y + this.to.height / 2;\n\n    // Create s-shape curve between the two points\n    ctx.beginPath();\n    ctx.strokeStyle = this.color;\n    ctx.lineWidth = this.width;\n    ctx.moveTo(startX, startY);\n    const dx = endX - startX;\n    // if dy is negative, the curve will be an s-shape\n    // if dy is positive, we should flip the s-shape curve\n    const dy = endY - startY;\n\n    const controlPointFactor = Math.abs(dy) * 0.5;\n    const x1 = startX + dx * 0.5;\n    const y1 =\n      startY + dy * 0.5 + (dy > 0 ? -controlPointFactor : controlPointFactor);\n    const x2 = startX + dx * 0.5;\n    const y2 =\n      startY + dy * 0.5 + (dy > 0 ? controlPointFactor : -controlPointFactor);\n\n    ctx.bezierCurveTo(x1, y1, x2, y2, endX, endY);\n    ctx.stroke();\n  }\n}\n","import { INode } from \"./node\";\nimport { Edge } from \"./edge\";\n\n/**\n * Graph class represents a graph of nodes and edges.\n * @class\n * @property {INode[]} nodes - The nodes in the graph.\n * @property {Edge[]} edges - The edges in the graph.\n */\nexport class Graph {\n  nodes: INode[] = [];\n  edges: Edge[] = [];\n\n  addNode(node: INode) {\n    this.nodes.push(node);\n  }\n\n  getNode(id: string) {\n    return this.nodes.find((node) => node.id === id);\n  }\n\n  addEdge({ from, to }: { from: INode; to: INode }) {\n    const edge = new Edge(from, to);\n    this.edges.push(edge);\n  }\n\n  removeNode(node: INode) {\n    this.nodes = this.nodes.filter((n) => n !== node);\n    this.edges = this.edges.filter(\n      (edge) => edge.from !== node && edge.to !== node\n    );\n  }\n\n  removeEdge(edge: Edge) {\n    this.edges = this.edges.filter((e) => e !== edge);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    this.edges.forEach((edge) => {\n      edge.draw(ctx);\n    });\n    this.nodes.forEach((node) => {\n      node.draw(ctx);\n    });\n  }\n}\n","export interface INode {\n  /**\n   * The unique identifier of the node.\n   */\n  id: string;\n\n  /**\n   * The x coordinate of the node.\n   */\n  x: number;\n\n  /**\n   * The y coordinate of the node.\n   */\n  y: number;\n\n  /**\n   * The width of the node.\n   */\n  width: number;\n\n  /**\n   * The height of the node.\n   */\n  height: number;\n\n  /**\n   * The color of the node.\n   */\n  color: string;\n\n  /**\n   * The label of the node.\n   */\n  label: string;\n\n  /**\n   * True if the node is being hovered over, false otherwise.\n   */\n  isHovered: boolean;\n\n  /**\n   * True if the node is being dragged, false otherwise.\n   */\n  isDragging: boolean;\n\n  /**\n   * Draw the node on the canvas.\n   * @param ctx - The 2D rendering context of the canvas.\n   */\n  draw(ctx: CanvasRenderingContext2D): void;\n\n  /**\n   * Handle the hover event on the node.\n   */\n  hoverOn(): void;\n\n  /**\n   * Handle the mouse off hover event on the node.\n   */\n  hoverOff(): void;\n\n  /**\n   * Handle the drag start event on the node.\n   * @param x - The x coordinate of the mouse.\n   * @param y - The y coordinate of the mouse.\n   */\n  onDragStart(x: number, y: number): void;\n\n  /**\n   * Handle the drag event on the node.\n   * @param x - The x coordinate of the mouse.\n   * @param y - The y coordinate of the mouse.\n   */\n  onDrag(x: number, y: number): void;\n\n  /**\n   * Handle the drop event on the node.\n   */\n  onDragEnd(): void;\n\n  /**\n   * Check if the node contains a point.\n   * @param x - The x coordinate of the point.\n   * @param y - The y coordinate of the point.\n   * @returns True if the node contains the point, false otherwise.\n   */\n  containsPoint(x: number, y: number): boolean;\n}\n\n/**\n * Node class represents a node in a graph.\n * @class\n * @property {number} x - The x coordinate of the node.\n * @property {number} y - The y coordinate of the node.\n * @property {number} width - The width of the node.\n * @property {number} height - The height of the node.\n */\nexport class Node implements INode {\n  id: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  color: string;\n  label: string;\n  isHovered = false;\n  isDragging = false;\n  dragOffsetX = 0;\n  dragOffsetY = 0;\n\n  constructor({\n    id,\n    x,\n    y,\n    width = 200,\n    height = 50,\n    label = \"\",\n    color = \"#444\",\n  }: {\n    id: string;\n    x: number;\n    y: number;\n    width?: number;\n    height?: number;\n    label?: string;\n    color?: string;\n  }) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.label = label;\n    this.color = color;\n  }\n\n  /**\n   * Sets the drag start position for the node.\n   * @param x - The x-coordinate of the drag start position.\n   * @param y - The y-coordinate of the drag start position.\n   */\n  public onDragStart(x: number, y: number) {\n    this.isDragging = true;\n    this.dragOffsetX = x - this.x;\n    this.dragOffsetY = y - this.y;\n  }\n\n  /**\n   * Resets the drag offset after dragging ends.\n   */\n  public onDragEnd() {\n    this.isDragging = false;\n    this.dragOffsetX = 0;\n    this.dragOffsetY = 0;\n  }\n\n  /**\n   * Updates the node position while dragging.\n   * @param x - The x-coordinate of the drag position.\n   * @param y - The y-coordinate of the drag position.\n   */\n  public onDrag(x: number, y: number): void {\n    this.x = x - this.dragOffsetX;\n    this.y = y - this.dragOffsetY;\n  }\n\n  public hoverOn(): void {\n    this.isHovered = true;\n  }\n\n  public hoverOff(): void {\n    this.isHovered = false;\n  }\n\n  public static createId() {\n    return Math.random().toString(36).substring(2);\n  }\n\n  public containsPoint(x: number, y: number) {\n    return (\n      x >= this.x &&\n      x <= this.x + this.width &&\n      y >= this.y &&\n      y <= this.y + this.height\n    );\n  }\n\n  public draw(ctx: CanvasRenderingContext2D) {\n    this.drawRectangle(ctx);\n    this.drawLabel(ctx);\n  }\n\n  private drawRectangle(ctx: CanvasRenderingContext2D) {\n    // Add a shadow to the node\n    ctx.shadowColor = \"rgba(0, 0, 0, 0.2)\";\n    ctx.shadowBlur = 10;\n    ctx.shadowOffsetX = 5;\n    ctx.shadowOffsetY = 5;\n\n    const radius = 5;\n    ctx.fillStyle = this.color;\n    ctx.beginPath();\n    ctx.moveTo(this.x + radius, this.y);\n    ctx.lineTo(this.x + this.width - radius, this.y);\n    ctx.quadraticCurveTo(\n      this.x + this.width,\n      this.y,\n      this.x + this.width,\n      this.y + radius\n    );\n    ctx.lineTo(this.x + this.width, this.y + this.height - radius);\n    ctx.quadraticCurveTo(\n      this.x + this.width,\n      this.y + this.height,\n      this.x + this.width - radius,\n      this.y + this.height\n    );\n    ctx.lineTo(this.x + radius, this.y + this.height);\n    ctx.quadraticCurveTo(\n      this.x,\n      this.y + this.height,\n      this.x,\n      this.y + this.height - radius\n    );\n    ctx.lineTo(this.x, this.y + radius);\n    ctx.quadraticCurveTo(this.x, this.y, this.x + radius, this.y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    // Add a white border around the node\n    ctx.strokeStyle = \"white\";\n    ctx.lineWidth = this.isHovered ? 2 : 1;\n    ctx.stroke();\n  }\n\n  private drawLabel(ctx: CanvasRenderingContext2D) {\n    ctx.fillStyle = \"white\";\n    ctx.font = \"bold 20px Arial\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    ctx.fillText(this.label, this.x + this.width / 2, this.y + this.height / 2);\n\n    // Add a shadow to the text\n    ctx.shadowColor = \"rgba(0, 0, 0, 0.2)\";\n    ctx.shadowBlur = 5;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n  }\n}\n","import { INode, Node } from \"./node\";\nimport { Edge } from \"./edge\";\nimport { Graph } from \"./index\";\n\n/**\n * The Serializer class provides methods to serialize and deserialize a graph.\n */\nexport class Serializer {\n  /**\n   * Serialize the graph to a JSON string.\n   * @param graph - The graph to serialize.\n   * @returns A JSON string representing the graph.\n   */\n  public static serialize(graph: Graph): string {\n    const nodes = graph.nodes.map((node: INode) => ({\n      id: node.id,\n      x: node.x,\n      y: node.y,\n      width: node.width,\n      height: node.height,\n      color: node.color,\n    }));\n\n    const edges = graph.edges.map((edge: Edge) => ({\n      to: edge.to.id,\n      from: edge.from.id,\n    }));\n\n    return JSON.stringify({ nodes, edges });\n  }\n\n  /**\n   * Deserialize a JSON string to a graph.\n   * @param data - The JSON string representing the graph.\n   * @returns The deserialized graph.\n   */\n  static deserialize(data: string): Graph {\n    type EdgeJson = {\n      to: string;\n      from: string;\n    };\n\n    const { nodes, edges } = JSON.parse(data) as {\n      nodes: INode[];\n      edges: EdgeJson[];\n    };\n\n    const graph = new Graph();\n\n    // Add nodes to the graph\n    nodes.forEach((node: INode) => graph.addNode(new Node(node)));\n\n    // Add edges to the graph\n    edges.forEach((edge: EdgeJson) => {\n      const from = graph.nodes.find((node: INode) => node.id === edge.from);\n      const to = graph.nodes.find((node: INode) => node.id === edge.to);\n\n      if (from && to) {\n        graph.addEdge({ from, to });\n      } else {\n        throw new Error(`Invalid edge: ${edge.from} -> ${edge.to}`);\n      }\n    });\n\n    return graph;\n  }\n}\n","import { Graph } from \"./graph\";\nimport { INode } from \"./graph/node\";\nimport { Edge } from \"./graph/edge\";\n\n/**\n * InfiniteCanvas class represents a canvas that can be infinitely scrolled.\n * @class\n * @property {HTMLCanvasElement}\n * @property {CanvasRenderingContext2D}\n * @property {Graph}\n */\nexport class InfiniteCanvas {\n  /**\n   * The HTML canvas element.\n   */\n  private canvas: HTMLCanvasElement;\n\n  /**\n   * The 2D rendering context of the canvas.\n   */\n  private ctx: CanvasRenderingContext2D;\n\n  /**\n   * The graph to be drawn on the canvas.\n   */\n  private graph: Graph;\n\n  /**\n   * The background color of the canvas.\n   */\n  private background: string;\n\n  /**\n   * The scale factor for zooming.\n   */\n  private scale = 1;\n\n  /**\n   * The X offset for panning.\n   */\n  private offsetX = 0;\n\n  /**\n   * The Y offset for panning.\n   */\n  private offsetY = 0;\n\n  /**\n   * Flag indicating whether panning is in progress.\n   */\n  private isPanning = false;\n\n  /**\n   * The starting X coordinate for panning.\n   */\n  private startX = 0;\n\n  /**\n   * The starting Y coordinate for panning.\n   */\n  private startY = 0;\n\n  /**\n   * Flag indicating whether a node is being dragged.\n   */\n  private isDragging = false;\n\n  /**\n   * The minimum zoom level.\n   */\n  private minZoom = 0.1;\n\n  /**\n   * The maximum zoom level.\n   */\n  private maxZoom = 10;\n\n  /**\n   * Creates a new instance of InfiniteCanvas.\n   * @param options - The options for creating the canvas.\n   */\n  constructor({\n    canvas,\n    background = \"#333\",\n    minZoom = 0.1,\n    maxZoom = 10,\n  }: {\n    canvas: HTMLCanvasElement;\n    background?: string;\n    minZoom?: number;\n    maxZoom?: number;\n  }) {\n    this.canvas = canvas;\n    this.background = background;\n    this.minZoom = minZoom;\n    this.maxZoom = maxZoom;\n\n    this.ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n    this.graph = new Graph();\n\n    // Canvas Event Listeners\n    this.canvas.addEventListener(\"wheel\", this.zoom.bind(this));\n    this.canvas.addEventListener(\"mousedown\", this.startPan.bind(this));\n    this.canvas.addEventListener(\"mousemove\", this.pan.bind(this));\n    this.canvas.addEventListener(\"mouseup\", this.endPan.bind(this));\n    this.canvas.addEventListener(\"mouseleave\", this.endPan.bind(this));\n\n    // Node Event Listeners\n    this.canvas.addEventListener(\"mousemove\", this.hover.bind(this));\n    this.canvas.addEventListener(\"mousedown\", this.startDrag.bind(this));\n    this.canvas.addEventListener(\"mousemove\", this.drag.bind(this));\n    this.canvas.addEventListener(\"mouseup\", this.dragEnd.bind(this));\n\n    this.resizeCanvas();\n  }\n\n  /**\n   * Sets the graph to be drawn on the canvas.\n   * @param graph - The graph to be set.\n   */\n  public setGraph(graph: Graph) {\n    this.graph = graph;\n    this.draw();\n  }\n\n  /**\n   * Adds a node to the canvas.\n   * @param options - The options for adding a node.\n   */\n  public addNode({ node }: { node: INode }) {\n    this.graph.addNode(node);\n    this.draw();\n  }\n\n  /**\n   * Removes a node from the canvas.\n   * @param options - The options for removing a node.\n   */\n  public removeNode({ node }: { node: INode }) {\n    this.graph.removeNode(node);\n    this.draw();\n  }\n\n  /**\n   * Adds an edge to the canvas.\n   * @param options - The options for adding an edge.\n   */\n  public addEdge({ edge }: { edge: Edge }) {\n    this.graph.addEdge(edge);\n    this.draw();\n  }\n\n  /**\n   * Removes an edge from the canvas.\n   * @param options - The options for removing an edge.\n   */\n  public removeEdge({ edge }: { edge: Edge }) {\n    this.graph.removeEdge(edge);\n    this.draw();\n  }\n\n  /**\n   * Gets a node by its ID.\n   * @param id - The ID of the node.\n   * @returns The node with the given ID.\n   */\n  public getNode(id: string) {\n    return this.graph.getNode(id);\n  }\n\n  /**\n   * Resizes the canvas to fit the window size.\n   */\n  private resizeCanvas() {\n    this.canvas.width = window.innerWidth;\n    this.canvas.height = window.innerHeight;\n    this.draw();\n  }\n\n  /**\n   * Handles the hover event on the canvas.\n   * @param event - The mouse event.\n   */\n  private hover(event: MouseEvent) {\n    const { x: mouseX, y: mouseY } = this.getMouseCoordinates(event);\n    this.graph.nodes.forEach((node) => {\n      node.hoverOff();\n    });\n\n    const selectedNode = this.graph.nodes.findLast((node) => {\n      if (node.containsPoint(mouseX, mouseY)) {\n        return node;\n      }\n    });\n\n    if (selectedNode) {\n      this.isDragging = true;\n      selectedNode.hoverOn();\n    }\n\n    this.draw();\n  }\n\n  /**\n   * Handles the drag event on the canvas.\n   * @param event - The mouse event.\n   */\n  private drag(event: MouseEvent) {\n    if (!this.isDragging) return;\n\n    const { x: mouseX, y: mouseY } = this.getMouseCoordinates(event);\n    this.graph.nodes\n      .filter((node) => node.isDragging)\n      .forEach((node) => node.onDrag(mouseX, mouseY));\n\n    this.draw();\n  }\n\n  /**\n   * Handles the end of dragging.\n   */\n  private dragEnd() {\n    this.isDragging = false;\n    this.graph.nodes.forEach((node) => node.onDragEnd());\n\n    this.draw();\n  }\n\n  /**\n   * Handles the click event on the canvas.\n   * @param event - The mouse event.\n   */\n  private startDrag(event: MouseEvent) {\n    this.isDragging = false;\n\n    const { x: mouseX, y: mouseY } = this.getMouseCoordinates(event);\n    const selectedNode = this.graph.nodes.findLast((node) => {\n      if (node.containsPoint(mouseX, mouseY)) {\n        return node;\n      }\n    });\n\n    if (selectedNode) {\n      this.isDragging = true;\n      selectedNode.onDragStart(mouseX, mouseY);\n      this.draw();\n    }\n  }\n\n  /**\n   * Handles the start of panning.\n   * @param event - The mouse event.\n   */\n  private startPan(event: MouseEvent) {\n    this.isPanning = true;\n    this.startX = event.clientX - this.offsetX;\n    this.startY = event.clientY - this.offsetY;\n  }\n\n  /**\n   * Handles panning.\n   * @param event - The mouse event.\n   */\n  private pan(event: MouseEvent) {\n    if (!this.isPanning || this.isDragging) return;\n    this.offsetX = event.clientX - this.startX;\n    this.offsetY = event.clientY - this.startY;\n    this.draw();\n  }\n\n  /**\n   * Handles the end of panning.\n   */\n  private endPan() {\n    this.isPanning = false;\n  }\n\n  /**\n   * Gets the mouse position on the canvas.\n   *\n   * @param evt - The mouse event object.\n   * @returns An object containing the x and y coordinates of the mouse.\n   */\n  private getMouseCoordinates(evt: MouseEvent) {\n    const rect = this.canvas.getBoundingClientRect();\n    const canvasCoordinates = {\n      x:\n        ((evt.clientX - rect.left) / (rect.right - rect.left)) *\n        this.canvas.width,\n      y:\n        ((evt.clientY - rect.top) / (rect.bottom - rect.top)) *\n        this.canvas.height,\n    };\n\n    const x = (canvasCoordinates.x - this.offsetX) / this.scale;\n    const y = (canvasCoordinates.y - this.offsetY) / this.scale;\n    return {\n      x,\n      y,\n    };\n  }\n\n  /**\n   * Handles zooming.\n   * @param event - The wheel event.\n   */\n  private zoom(event: WheelEvent) {\n    event.preventDefault();\n\n    const scaleFactor = 1.1;\n    const rect = this.canvas.getBoundingClientRect();\n    const mouseX = event.clientX - rect.left;\n    const mouseY = event.clientY - rect.top;\n    const zoomIn = event.deltaY < 0;\n\n    const worldX = (mouseX - this.offsetX) / this.scale;\n    const worldY = (mouseY - this.offsetY) / this.scale;\n\n    if (this.scale * (zoomIn ? scaleFactor : 1 / scaleFactor) < this.minZoom) {\n      return;\n    }\n\n    if (this.scale * (zoomIn ? scaleFactor : 1 / scaleFactor) > this.maxZoom) {\n      return;\n    }\n\n    this.scale *= zoomIn ? scaleFactor : 1 / scaleFactor;\n\n    this.offsetX = mouseX - worldX * this.scale;\n    this.offsetY = mouseY - worldY * this.scale;\n\n    this.draw();\n  }\n\n  /**\n   * Draws the background grid on the canvas.\n   */\n  private drawBackground() {\n    const gridSize = 25;\n    this.ctx.fillStyle = this.background;\n    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    // Add dots\n    this.ctx.fillStyle = \"rgba(255, 255, 255, 0.1)\";\n    for (\n      let x = -this.offsetX % gridSize;\n      x < this.canvas.width;\n      x += gridSize\n    ) {\n      for (\n        let y = -this.offsetY % gridSize;\n        y < this.canvas.height;\n        y += gridSize\n      ) {\n        this.ctx.beginPath();\n        this.ctx.arc(x, y, 1, 0, 2 * Math.PI);\n        this.ctx.fill();\n      }\n    }\n  }\n\n  /**\n   * Draws the canvas.\n   */\n  private draw() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.drawBackground();\n\n    this.ctx.save();\n    this.ctx.translate(this.offsetX, this.offsetY);\n    this.ctx.scale(this.scale, this.scale);\n    this.graph.draw(this.ctx);\n    this.ctx.restore();\n  }\n}\n"],"mappings":"yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,UAAAE,EAAA,UAAAC,EAAA,mBAAAC,EAAA,SAAAC,EAAA,eAAAC,IAAA,eAAAC,EAAAP,GCUO,IAAMQ,EAAN,KAAW,CAChB,GACA,KACA,MAAgB,OAChB,MAAgB,EAEhB,YAAYC,EAAaC,EAAW,CAClC,KAAK,KAAOD,EACZ,KAAK,GAAKC,CACZ,CAEA,KAAKC,EAA+B,CAGlC,IAAMC,EAAS,KAAK,KAAK,EAAI,KAAK,KAAK,MACjCC,EAAS,KAAK,KAAK,EAAI,KAAK,KAAK,OAAS,EAE1CC,EAAO,KAAK,GAAG,EACfC,EAAO,KAAK,GAAG,EAAI,KAAK,GAAG,OAAS,EAG1CJ,EAAI,UAAU,EACdA,EAAI,YAAc,KAAK,MACvBA,EAAI,UAAY,KAAK,MACrBA,EAAI,OAAOC,EAAQC,CAAM,EACzB,IAAMG,EAAKF,EAAOF,EAGZK,EAAKF,EAAOF,EAEZK,EAAqB,KAAK,IAAID,CAAE,EAAI,GACpCE,EAAKP,EAASI,EAAK,GACnBI,EACJP,EAASI,EAAK,IAAOA,EAAK,EAAI,CAACC,EAAqBA,GAChDG,EAAKT,EAASI,EAAK,GACnBM,EACJT,EAASI,EAAK,IAAOA,EAAK,EAAIC,EAAqB,CAACA,GAEtDP,EAAI,cAAcQ,EAAIC,EAAIC,EAAIC,EAAIR,EAAMC,CAAI,EAC5CJ,EAAI,OAAO,CACb,CACF,EC1CO,IAAMY,EAAN,KAAY,CACjB,MAAiB,CAAC,EAClB,MAAgB,CAAC,EAEjB,QAAQC,EAAa,CACnB,KAAK,MAAM,KAAKA,CAAI,CACtB,CAEA,QAAQC,EAAY,CAClB,OAAO,KAAK,MAAM,KAAMD,GAASA,EAAK,KAAOC,CAAE,CACjD,CAEA,QAAQ,CAAE,KAAAC,EAAM,GAAAC,CAAG,EAA+B,CAChD,IAAMC,EAAO,IAAIC,EAAKH,EAAMC,CAAE,EAC9B,KAAK,MAAM,KAAKC,CAAI,CACtB,CAEA,WAAWJ,EAAa,CACtB,KAAK,MAAQ,KAAK,MAAM,OAAQM,GAAMA,IAAMN,CAAI,EAChD,KAAK,MAAQ,KAAK,MAAM,OACrBI,GAASA,EAAK,OAASJ,GAAQI,EAAK,KAAOJ,CAC9C,CACF,CAEA,WAAWI,EAAY,CACrB,KAAK,MAAQ,KAAK,MAAM,OAAQG,GAAMA,IAAMH,CAAI,CAClD,CAEA,KAAKI,EAA+B,CAClC,KAAK,MAAM,QAASJ,GAAS,CAC3BA,EAAK,KAAKI,CAAG,CACf,CAAC,EACD,KAAK,MAAM,QAASR,GAAS,CAC3BA,EAAK,KAAKQ,CAAG,CACf,CAAC,CACH,CACF,ECqDO,IAAMC,EAAN,KAA4B,CACjC,GACA,EACA,EACA,MACA,OACA,MACA,MACA,UAAY,GACZ,WAAa,GACb,YAAc,EACd,YAAc,EAEd,YAAY,CACV,GAAAC,EACA,EAAAC,EACA,EAAAC,EACA,MAAAC,EAAQ,IACR,OAAAC,EAAS,GACT,MAAAC,EAAQ,GACR,MAAAC,EAAQ,MACV,EAQG,CACD,KAAK,GAAKN,EACV,KAAK,EAAIC,EACT,KAAK,EAAIC,EACT,KAAK,MAAQC,EACb,KAAK,OAASC,EACd,KAAK,MAAQC,EACb,KAAK,MAAQC,CACf,CAOO,YAAYL,EAAWC,EAAW,CACvC,KAAK,WAAa,GAClB,KAAK,YAAcD,EAAI,KAAK,EAC5B,KAAK,YAAcC,EAAI,KAAK,CAC9B,CAKO,WAAY,CACjB,KAAK,WAAa,GAClB,KAAK,YAAc,EACnB,KAAK,YAAc,CACrB,CAOO,OAAOD,EAAWC,EAAiB,CACxC,KAAK,EAAID,EAAI,KAAK,YAClB,KAAK,EAAIC,EAAI,KAAK,WACpB,CAEO,SAAgB,CACrB,KAAK,UAAY,EACnB,CAEO,UAAiB,CACtB,KAAK,UAAY,EACnB,CAEA,OAAc,UAAW,CACvB,OAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,UAAU,CAAC,CAC/C,CAEO,cAAcD,EAAWC,EAAW,CACzC,OACED,GAAK,KAAK,GACVA,GAAK,KAAK,EAAI,KAAK,OACnBC,GAAK,KAAK,GACVA,GAAK,KAAK,EAAI,KAAK,MAEvB,CAEO,KAAKK,EAA+B,CACzC,KAAK,cAAcA,CAAG,EACtB,KAAK,UAAUA,CAAG,CACpB,CAEQ,cAAcA,EAA+B,CAEnDA,EAAI,YAAc,qBAClBA,EAAI,WAAa,GACjBA,EAAI,cAAgB,EACpBA,EAAI,cAAgB,EAEpB,IAAMC,EAAS,EACfD,EAAI,UAAY,KAAK,MACrBA,EAAI,UAAU,EACdA,EAAI,OAAO,KAAK,EAAIC,EAAQ,KAAK,CAAC,EAClCD,EAAI,OAAO,KAAK,EAAI,KAAK,MAAQC,EAAQ,KAAK,CAAC,EAC/CD,EAAI,iBACF,KAAK,EAAI,KAAK,MACd,KAAK,EACL,KAAK,EAAI,KAAK,MACd,KAAK,EAAIC,CACX,EACAD,EAAI,OAAO,KAAK,EAAI,KAAK,MAAO,KAAK,EAAI,KAAK,OAASC,CAAM,EAC7DD,EAAI,iBACF,KAAK,EAAI,KAAK,MACd,KAAK,EAAI,KAAK,OACd,KAAK,EAAI,KAAK,MAAQC,EACtB,KAAK,EAAI,KAAK,MAChB,EACAD,EAAI,OAAO,KAAK,EAAIC,EAAQ,KAAK,EAAI,KAAK,MAAM,EAChDD,EAAI,iBACF,KAAK,EACL,KAAK,EAAI,KAAK,OACd,KAAK,EACL,KAAK,EAAI,KAAK,OAASC,CACzB,EACAD,EAAI,OAAO,KAAK,EAAG,KAAK,EAAIC,CAAM,EAClCD,EAAI,iBAAiB,KAAK,EAAG,KAAK,EAAG,KAAK,EAAIC,EAAQ,KAAK,CAAC,EAC5DD,EAAI,UAAU,EAEdA,EAAI,KAAK,EAGTA,EAAI,YAAc,QAClBA,EAAI,UAAY,KAAK,UAAY,EAAI,EACrCA,EAAI,OAAO,CACb,CAEQ,UAAUA,EAA+B,CAC/CA,EAAI,UAAY,QAChBA,EAAI,KAAO,kBACXA,EAAI,UAAY,SAChBA,EAAI,aAAe,SAEnBA,EAAI,SAAS,KAAK,MAAO,KAAK,EAAI,KAAK,MAAQ,EAAG,KAAK,EAAI,KAAK,OAAS,CAAC,EAG1EA,EAAI,YAAc,qBAClBA,EAAI,WAAa,EACjBA,EAAI,cAAgB,EACpBA,EAAI,cAAgB,CACtB,CACF,ECpPO,IAAME,EAAN,KAAiB,CAMtB,OAAc,UAAUC,EAAsB,CAC5C,IAAMC,EAAQD,EAAM,MAAM,IAAKE,IAAiB,CAC9C,GAAIA,EAAK,GACT,EAAGA,EAAK,EACR,EAAGA,EAAK,EACR,MAAOA,EAAK,MACZ,OAAQA,EAAK,OACb,MAAOA,EAAK,KACd,EAAE,EAEIC,EAAQH,EAAM,MAAM,IAAKI,IAAgB,CAC7C,GAAIA,EAAK,GAAG,GACZ,KAAMA,EAAK,KAAK,EAClB,EAAE,EAEF,OAAO,KAAK,UAAU,CAAE,MAAAH,EAAO,MAAAE,CAAM,CAAC,CACxC,CAOA,OAAO,YAAYE,EAAqB,CAMtC,GAAM,CAAE,MAAAJ,EAAO,MAAAE,CAAM,EAAI,KAAK,MAAME,CAAI,EAKlCL,EAAQ,IAAIM,EAGlB,OAAAL,EAAM,QAASC,GAAgBF,EAAM,QAAQ,IAAIO,EAAKL,CAAI,CAAC,CAAC,EAG5DC,EAAM,QAASC,GAAmB,CAChC,IAAMI,EAAOR,EAAM,MAAM,KAAME,GAAgBA,EAAK,KAAOE,EAAK,IAAI,EAC9DK,EAAKT,EAAM,MAAM,KAAME,GAAgBA,EAAK,KAAOE,EAAK,EAAE,EAEhE,GAAII,GAAQC,EACVT,EAAM,QAAQ,CAAE,KAAAQ,EAAM,GAAAC,CAAG,CAAC,MAE1B,OAAM,IAAI,MAAM,iBAAiBL,EAAK,IAAI,OAAOA,EAAK,EAAE,EAAE,CAE9D,CAAC,EAEMJ,CACT,CACF,ECvDO,IAAMU,EAAN,KAAqB,CAIlB,OAKA,IAKA,MAKA,WAKA,MAAQ,EAKR,QAAU,EAKV,QAAU,EAKV,UAAY,GAKZ,OAAS,EAKT,OAAS,EAKT,WAAa,GAKb,QAAU,GAKV,QAAU,GAMlB,YAAY,CACV,OAAAC,EACA,WAAAC,EAAa,OACb,QAAAC,EAAU,GACV,QAAAC,EAAU,EACZ,EAKG,CACD,KAAK,OAASH,EACd,KAAK,WAAaC,EAClB,KAAK,QAAUC,EACf,KAAK,QAAUC,EAEf,KAAK,IAAMH,EAAO,WAAW,IAAI,EACjC,KAAK,MAAQ,IAAII,EAGjB,KAAK,OAAO,iBAAiB,QAAS,KAAK,KAAK,KAAK,IAAI,CAAC,EAC1D,KAAK,OAAO,iBAAiB,YAAa,KAAK,SAAS,KAAK,IAAI,CAAC,EAClE,KAAK,OAAO,iBAAiB,YAAa,KAAK,IAAI,KAAK,IAAI,CAAC,EAC7D,KAAK,OAAO,iBAAiB,UAAW,KAAK,OAAO,KAAK,IAAI,CAAC,EAC9D,KAAK,OAAO,iBAAiB,aAAc,KAAK,OAAO,KAAK,IAAI,CAAC,EAGjE,KAAK,OAAO,iBAAiB,YAAa,KAAK,MAAM,KAAK,IAAI,CAAC,EAC/D,KAAK,OAAO,iBAAiB,YAAa,KAAK,UAAU,KAAK,IAAI,CAAC,EACnE,KAAK,OAAO,iBAAiB,YAAa,KAAK,KAAK,KAAK,IAAI,CAAC,EAC9D,KAAK,OAAO,iBAAiB,UAAW,KAAK,QAAQ,KAAK,IAAI,CAAC,EAE/D,KAAK,aAAa,CACpB,CAMO,SAASC,EAAc,CAC5B,KAAK,MAAQA,EACb,KAAK,KAAK,CACZ,CAMO,QAAQ,CAAE,KAAAC,CAAK,EAAoB,CACxC,KAAK,MAAM,QAAQA,CAAI,EACvB,KAAK,KAAK,CACZ,CAMO,WAAW,CAAE,KAAAA,CAAK,EAAoB,CAC3C,KAAK,MAAM,WAAWA,CAAI,EAC1B,KAAK,KAAK,CACZ,CAMO,QAAQ,CAAE,KAAAC,CAAK,EAAmB,CACvC,KAAK,MAAM,QAAQA,CAAI,EACvB,KAAK,KAAK,CACZ,CAMO,WAAW,CAAE,KAAAA,CAAK,EAAmB,CAC1C,KAAK,MAAM,WAAWA,CAAI,EAC1B,KAAK,KAAK,CACZ,CAOO,QAAQC,EAAY,CACzB,OAAO,KAAK,MAAM,QAAQA,CAAE,CAC9B,CAKQ,cAAe,CACrB,KAAK,OAAO,MAAQ,OAAO,WAC3B,KAAK,OAAO,OAAS,OAAO,YAC5B,KAAK,KAAK,CACZ,CAMQ,MAAMC,EAAmB,CAC/B,GAAM,CAAE,EAAGC,EAAQ,EAAGC,CAAO,EAAI,KAAK,oBAAoBF,CAAK,EAC/D,KAAK,MAAM,MAAM,QAASH,GAAS,CACjCA,EAAK,SAAS,CAChB,CAAC,EAED,IAAMM,EAAe,KAAK,MAAM,MAAM,SAAUN,GAAS,CACvD,GAAIA,EAAK,cAAcI,EAAQC,CAAM,EACnC,OAAOL,CAEX,CAAC,EAEGM,IACF,KAAK,WAAa,GAClBA,EAAa,QAAQ,GAGvB,KAAK,KAAK,CACZ,CAMQ,KAAKH,EAAmB,CAC9B,GAAI,CAAC,KAAK,WAAY,OAEtB,GAAM,CAAE,EAAGC,EAAQ,EAAGC,CAAO,EAAI,KAAK,oBAAoBF,CAAK,EAC/D,KAAK,MAAM,MACR,OAAQH,GAASA,EAAK,UAAU,EAChC,QAASA,GAASA,EAAK,OAAOI,EAAQC,CAAM,CAAC,EAEhD,KAAK,KAAK,CACZ,CAKQ,SAAU,CAChB,KAAK,WAAa,GAClB,KAAK,MAAM,MAAM,QAASL,GAASA,EAAK,UAAU,CAAC,EAEnD,KAAK,KAAK,CACZ,CAMQ,UAAUG,EAAmB,CACnC,KAAK,WAAa,GAElB,GAAM,CAAE,EAAGC,EAAQ,EAAGC,CAAO,EAAI,KAAK,oBAAoBF,CAAK,EACzDG,EAAe,KAAK,MAAM,MAAM,SAAUN,GAAS,CACvD,GAAIA,EAAK,cAAcI,EAAQC,CAAM,EACnC,OAAOL,CAEX,CAAC,EAEGM,IACF,KAAK,WAAa,GAClBA,EAAa,YAAYF,EAAQC,CAAM,EACvC,KAAK,KAAK,EAEd,CAMQ,SAASF,EAAmB,CAClC,KAAK,UAAY,GACjB,KAAK,OAASA,EAAM,QAAU,KAAK,QACnC,KAAK,OAASA,EAAM,QAAU,KAAK,OACrC,CAMQ,IAAIA,EAAmB,CACzB,CAAC,KAAK,WAAa,KAAK,aAC5B,KAAK,QAAUA,EAAM,QAAU,KAAK,OACpC,KAAK,QAAUA,EAAM,QAAU,KAAK,OACpC,KAAK,KAAK,EACZ,CAKQ,QAAS,CACf,KAAK,UAAY,EACnB,CAQQ,oBAAoBI,EAAiB,CAC3C,IAAMC,EAAO,KAAK,OAAO,sBAAsB,EACzCC,EAAoB,CACxB,GACIF,EAAI,QAAUC,EAAK,OAASA,EAAK,MAAQA,EAAK,MAChD,KAAK,OAAO,MACd,GACID,EAAI,QAAUC,EAAK,MAAQA,EAAK,OAASA,EAAK,KAChD,KAAK,OAAO,MAChB,EAEME,GAAKD,EAAkB,EAAI,KAAK,SAAW,KAAK,MAChDE,GAAKF,EAAkB,EAAI,KAAK,SAAW,KAAK,MACtD,MAAO,CACL,EAAAC,EACA,EAAAC,CACF,CACF,CAMQ,KAAKR,EAAmB,CAC9BA,EAAM,eAAe,EAErB,IAAMS,EAAc,IACdJ,EAAO,KAAK,OAAO,sBAAsB,EACzCJ,EAASD,EAAM,QAAUK,EAAK,KAC9BH,EAASF,EAAM,QAAUK,EAAK,IAC9BK,EAASV,EAAM,OAAS,EAExBW,GAAUV,EAAS,KAAK,SAAW,KAAK,MACxCW,GAAUV,EAAS,KAAK,SAAW,KAAK,MAE1C,KAAK,OAASQ,EAASD,EAAc,EAAIA,GAAe,KAAK,SAI7D,KAAK,OAASC,EAASD,EAAc,EAAIA,GAAe,KAAK,UAIjE,KAAK,OAASC,EAASD,EAAc,EAAIA,EAEzC,KAAK,QAAUR,EAASU,EAAS,KAAK,MACtC,KAAK,QAAUT,EAASU,EAAS,KAAK,MAEtC,KAAK,KAAK,EACZ,CAKQ,gBAAiB,CAEvB,KAAK,IAAI,UAAY,KAAK,WAC1B,KAAK,IAAI,SAAS,EAAG,EAAG,KAAK,OAAO,MAAO,KAAK,OAAO,MAAM,EAG7D,KAAK,IAAI,UAAY,2BACrB,QACML,EAAI,CAAC,KAAK,QAAU,GACxBA,EAAI,KAAK,OAAO,MAChBA,GAAK,GAEL,QACMC,EAAI,CAAC,KAAK,QAAU,GACxBA,EAAI,KAAK,OAAO,OAChBA,GAAK,GAEL,KAAK,IAAI,UAAU,EACnB,KAAK,IAAI,IAAID,EAAGC,EAAG,EAAG,EAAG,EAAI,KAAK,EAAE,EACpC,KAAK,IAAI,KAAK,CAGpB,CAKQ,MAAO,CACb,KAAK,IAAI,UAAU,EAAG,EAAG,KAAK,OAAO,MAAO,KAAK,OAAO,MAAM,EAC9D,KAAK,eAAe,EAEpB,KAAK,IAAI,KAAK,EACd,KAAK,IAAI,UAAU,KAAK,QAAS,KAAK,OAAO,EAC7C,KAAK,IAAI,MAAM,KAAK,MAAO,KAAK,KAAK,EACrC,KAAK,MAAM,KAAK,KAAK,GAAG,EACxB,KAAK,IAAI,QAAQ,CACnB,CACF","names":["src_exports","__export","Edge","Graph","InfiniteCanvas","Node","Serializer","__toCommonJS","Edge","from","to","ctx","startX","startY","endX","endY","dx","dy","controlPointFactor","x1","y1","x2","y2","Graph","node","id","from","to","edge","Edge","n","e","ctx","Node","id","x","y","width","height","label","color","ctx","radius","Serializer","graph","nodes","node","edges","edge","data","Graph","Node","from","to","InfiniteCanvas","canvas","background","minZoom","maxZoom","Graph","graph","node","edge","id","event","mouseX","mouseY","selectedNode","evt","rect","canvasCoordinates","x","y","scaleFactor","zoomIn","worldX","worldY"]}